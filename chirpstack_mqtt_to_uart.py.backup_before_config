#!/usr/bin/env python3
"""
ChirpStack MQTT to UART Bridge - Robuste Version
Sendet unformatierte Payload-Daten direkt über UART mit verbesserter Fehlerbehandlung
"""

import serial
import paho.mqtt.client as mqtt
import json
import time
import base64
import binascii
import logging
import signal
import sys
import os
from typing import Optional
import threading

class ChirpStackMQTTtoUART:
    def __init__(self, mqtt_broker: str = "localhost", mqtt_port: int = 1883, 
                 uart_port: str = '/dev/ttyAMA0', uart_baudrate: int = 115200,
                 log_level: str = "INFO"):
        
        # Logging Setup
        self.setup_logging(log_level)
        
        # Threading für graceful shutdown
        self.shutdown_event = threading.Event()
        self.setup_signal_handlers()
        
        # UART Setup
        self.uart_port = uart_port
        self.uart_baudrate = uart_baudrate
        self.ser = None
        self.setup_uart()
        
        # MQTT Setup
        self.mqtt_broker = mqtt_broker
        self.mqtt_port = mqtt_port
        self.client = None
        self.setup_mqtt()
        
        # Statistiken
        self.stats = {
            'messages_received': 0,
            'messages_sent': 0,
            'errors': 0,
            'last_message_time': None
        }

    def setup_logging(self, log_level: str):
        """Setup strukturiertes Logging"""
        logging.basicConfig(
            level=getattr(logging, log_level.upper()),
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.StreamHandler(sys.stdout),
                logging.FileHandler('chirpstack_bridge.log')
            ]
        )
        self.logger = logging.getLogger(__name__)

    def setup_signal_handlers(self):
        """Setup Signal Handler für graceful shutdown"""
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)

    def _signal_handler(self, signum, frame):
        """Handle shutdown signals"""
        self.logger.info(f"Received signal {signum}, shutting down gracefully...")
        self.shutdown_event.set()

    def setup_uart(self):
        """Setup UART mit Retry-Mechanismus"""
        max_retries = 3
        retry_delay = 2
        
        for attempt in range(max_retries):
            try:
                self.ser = serial.Serial(
                    port=self.uart_port,
                    baudrate=self.uart_baudrate,
                    bytesize=serial.EIGHTBITS,
                    parity=serial.PARITY_NONE,
                    stopbits=serial.STOPBITS_ONE,
                    timeout=1,
                    xonxoff=False,
                    rtscts=False,
                    dsrdtr=False
                )
                self.logger.info(f"UART initialisiert auf {self.uart_port} mit {self.uart_baudrate} baud")
                return
            except serial.SerialException as e:
                self.logger.error(f"UART Setup Fehler (Versuch {attempt + 1}/{max_retries}): {e}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                else:
                    raise

    def setup_mqtt(self):
        """Setup MQTT mit Wiederverbindung"""
        self.client = mqtt.Client()
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message
        self.client.on_disconnect = self.on_disconnect
        
        # Automatische Wiederverbindung aktivieren
        self.client.reconnect_delay_set(min_delay=1, max_delay=120)

    def on_connect(self, client, userdata, flags, rc):
        """MQTT Connect Callback"""
        if rc == 0:
            self.logger.info(f"Verbunden mit MQTT-Broker {self.mqtt_broker}:{self.mqtt_port}")
            client.subscribe("application/+/device/+/event/up")
            self.logger.info("Subscribed to application/+/device/+/event/up")
        else:
            self.logger.error(f"MQTT Verbindung fehlgeschlagen, Code: {rc}")

    def on_disconnect(self, client, userdata, rc):
        """MQTT Disconnect Callback"""
        if rc != 0:
            self.logger.warning(f"Unerwartete MQTT Trennung, Code: {rc}")

    def validate_payload(self, payload: bytes) -> bool:
        """Validiere Payload vor dem Senden"""
        if not payload:
            self.logger.warning("Leere Payload empfangen")
            return False
        
        if len(payload) > 255:  # Beispiel-Limit
            self.logger.warning(f"Payload zu groß: {len(payload)} Bytes")
            return False
        
        return True

    def decode_payload(self, json_data: dict) -> Optional[bytes]:
        """Dekodiere Payload mit robuster Fehlerbehandlung"""
        try:
            # Base64 dekodieren
            decoded_payload = base64.b64decode(json_data['data'])
            self.logger.debug(f"Base64 dekodiert ({len(decoded_payload)} Bytes): {decoded_payload.hex()}")
            
            # Prüfe ob es ASCII-Hex ist (doppelte Kodierung)
            try:
                ascii_hex = decoded_payload.decode('ascii')
                if all(c in '0123456789abcdefABCDEF' for c in ascii_hex):
                    self.logger.debug(f"ASCII-Hex String erkannt: {ascii_hex}")
                    final_payload = binascii.unhexlify(ascii_hex)
                    self.logger.debug(f"Final Payload ({len(final_payload)} Bytes): {final_payload.hex()}")
                    return final_payload
                else:
                    # Nicht alle Zeichen sind Hex, nutze direkte Daten
                    return decoded_payload
            except (UnicodeDecodeError, ValueError):
                # Falls nicht ASCII-Hex, nutze direkte Daten
                self.logger.debug(f"Direkte Payload ({len(decoded_payload)} Bytes): {decoded_payload.hex()}")
                return decoded_payload
                
        except Exception as e:
            self.logger.error(f"Fehler beim Dekodieren der Payload: {e}")
            return None

    def send_to_uart(self, payload: bytes) -> bool:
        """Sende Payload an UART mit Retry-Mechanismus"""
        max_retries = 3
        
        for attempt in range(max_retries):
            try:
                if not self.ser or not self.ser.is_open:
                    self.logger.warning("UART nicht verfügbar, versuche Wiederverbindung...")
                    self.setup_uart()
                
                bytes_written = self.ser.write(payload)
                self.ser.flush()
                
                if bytes_written == len(payload):
                    self.logger.info(f"{bytes_written} Bytes erfolgreich an UART gesendet")
                    self.stats['messages_sent'] += 1
                    return True
                else:
                    self.logger.warning(f"Nur {bytes_written}/{len(payload)} Bytes gesendet")
                    
            except serial.SerialException as e:
                self.logger.error(f"UART Fehler (Versuch {attempt + 1}/{max_retries}): {e}")
                if attempt < max_retries - 1:
                    time.sleep(0.5)
                    try:
                        self.ser.close()
                    except:
                        pass
                    self.setup_uart()
                else:
                    self.stats['errors'] += 1
                    return False
            except Exception as e:
                self.logger.error(f"Unerwarteter Fehler beim UART-Senden: {e}")
                self.stats['errors'] += 1
                return False
        
        return False

    def on_message(self, client, userdata, msg):
        """MQTT Message Callback mit verbesserter Fehlerbehandlung"""
        try:
            self.stats['messages_received'] += 1
            self.stats['last_message_time'] = time.time()
            
            self.logger.info(f"MQTT Nachricht erhalten: {msg.topic}")
            
            # JSON parsen
            json_data = json.loads(msg.payload)
            
            # Payload dekodieren
            payload = self.decode_payload(json_data)
            if payload is None:
                self.logger.error("Payload konnte nicht dekodiert werden")
                self.stats['errors'] += 1
                return
            
            # Payload validieren
            if not self.validate_payload(payload):
                self.logger.error("Payload-Validierung fehlgeschlagen")
                self.stats['errors'] += 1
                return
            
            # An UART senden
            if not self.send_to_uart(payload):
                self.logger.error("Fehler beim Senden an UART")
                self.stats['errors'] += 1
                
        except json.JSONDecodeError as e:
            self.logger.error(f"JSON Parse Fehler: {e}")
            self.stats['errors'] += 1
        except Exception as e:
            self.logger.error(f"Unerwarteter Fehler in on_message: {e}")
            self.stats['errors'] += 1

    def print_stats(self):
        """Drucke Statistiken"""
        self.logger.info(f"Statistiken: Empfangen={self.stats['messages_received']}, "
                        f"Gesendet={self.stats['messages_sent']}, "
                        f"Fehler={self.stats['errors']}")

    def connect_mqtt(self):
        """Verbinde mit MQTT-Broker"""
        try:
            self.client.connect(self.mqtt_broker, self.mqtt_port, 60)
            return True
        except Exception as e:
            self.logger.error(f"MQTT Verbindung fehlgeschlagen: {e}")
            return False

    def run(self):
        """Hauptlauf mit verbesserter Fehlerbehandlung"""
        self.logger.info("ChirpStack MQTT to UART Bridge gestartet...")
        
        # MQTT verbinden
        if not self.connect_mqtt():
            self.logger.error("Kann nicht mit MQTT-Broker verbinden")
            return
        
        # Statistik-Timer
        last_stats_time = time.time()
        stats_interval = 300  # 5 Minuten
        
        try:
            while not self.shutdown_event.is_set():
                # MQTT Loop mit Timeout
                self.client.loop(timeout=1.0)
                
                # Periodische Statistiken
                current_time = time.time()
                if current_time - last_stats_time > stats_interval:
                    self.print_stats()
                    last_stats_time = current_time
                
        except Exception as e:
            self.logger.error(f"Fehler in Hauptschleife: {e}")
        finally:
            self.cleanup()

    def cleanup(self):
        """Cleanup-Routine für graceful shutdown"""
        self.logger.info("Cleanup wird ausgeführt...")
        
        try:
            if self.client:
                self.client.disconnect()
                self.client.loop_stop()
        except:
            pass
        
        try:
            if self.ser and self.ser.is_open:
                self.ser.close()
        except:
            pass
        
        self.print_stats()
        self.logger.info("Bridge gestoppt")

if __name__ == "__main__":
    # Konfiguration über Environment-Variablen
    mqtt_broker = os.getenv('MQTT_BROKER', 'localhost')
    mqtt_port = int(os.getenv('MQTT_PORT', '1883'))
    uart_port = os.getenv('UART_PORT', '/dev/ttyAMA0')
    uart_baudrate = int(os.getenv('UART_BAUDRATE', '115200'))
    log_level = os.getenv('LOG_LEVEL', 'INFO')
    
    bridge = ChirpStackMQTTtoUART(
        mqtt_broker=mqtt_broker,
        mqtt_port=mqtt_port,
        uart_port=uart_port,
        uart_baudrate=uart_baudrate,
        log_level=log_level
    )
    bridge.run()
